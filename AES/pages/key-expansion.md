#### Key expansion

We work with 128-bit keys (16-bytes).  

We will simply use an array of 16 ints [0-255] rather than making 2D structures or using hex values.

Our example key is

```
>>> s = "Thats my Kung Fu"        
>>> L = [ord(c) for c in s]
>>> L
[84, 104, 97, 116, 115, 32, 109, 121, 
 32, 75, 117, 110, 103, 32, 70, 117]
>>>
>>> print([hex(i) for i in L])
['0x54', '0x68', '0x61', '0x74', 
'0x73', '0x20', '0x6d', '0x79', 
'0x20', '0x4b', '0x75', '0x6e', 
'0x67', '0x20', '0x46', '0x75']
```

In words, that is:

```
 84  104   97  116
115   32  109  121
 32   75  117  110
103   32   70  117
```

#### Circular byte shift

The ``g(w)`` of word ``w3`` (4 bytes) is generated by circular byte left shift of the last word of the key

```
 103,  32,   70,  117 ->  32,  70, 117,  103
0x67 0x20  0x46, 0x75   0x20 0x46 0x75  0x67
```

#### S-box substitution

The second step is a substitution from the S-box

```
SE = '''
 99 124 119 123 242 107 111 197  48   1 103  43 254 215 171 118
202 130 201 125 250  89  71 240 173 212 162 175 156 164 114 192
183 253 147  38  54  63 247 204  52 165 229 241 113 216  49  21
  4 199  35 195  24 150   5 154   7  18 128 226 235  39 178 117
  9 131  44  26  27 110  90 160  82  59 214 179  41 227  47 132
 83 209   0 237  32 252 177  91 106 203 190  57  74  76  88 207
208 239 170 251  67  77  51 133  69 249   2 127  80  60 159 168
 81 163  64 143 146 157  56 245 188 182 218  33  16 255 243 210
205  12  19 236  95 151  68  23 196 167 126  61 100  93  25 115
 96 129  79 220  34  42 144 136  70 238 184  20 222  94  11 219
224  50  58  10  73   6  36  92 194 211 172  98 145 149 228 121
231 200  55 109 141 213  78 169 108  86 244 234 101 122 174   8 
186 120  37  46  28 166 180 198 232 221 116  31  75 189 139 138
112 62  181 102  72   3 246  14  97  53  87 185 134 193  29 158
225 248 152  17 105 217 142 148 155  30 135 233 206  85  40 223
140 161 137  13 191 230  66 104  65 153  45  15 176  84 187  22
'''
```

I get   

```
 183,   90,  157,  133
0xb7, 0x5a, 0x9d, 0x85
```

Next, XOR with a "round constant", which is a byte followed by 3 null bytes.

The first round constant is just ``0x01`` + ``0x00``*3.

Subsequent round constants are ``RC[i] = \x02 x RC[i-1]`` for the first byte where this is classic GF multiplication.

```
RC = '''
1, 2, 4, 8, 16, 32, 
64, 128, 27, 54, 108, 
216, 171, 77, 154, 47
'''
```

In any case, we only need 10 of them:

```
int
  1    2    4    8   16
 32   64  128   27   54
hex
 01   02   04   08   10  
 20   40   80   1b   36
```

We had

```
 183,   90,  157,  133
0xb7, 0x5a, 0x9d, 0x85
```

For round 1 we do 

```
 183 ^    1 =  182
0xb7 ^ 0x01 = 0xb6
``` 

for the first byte.  We have produced ``g(w[3])``:

```
 182,   90,  157,  133
0xb6, 0x5a, 0x9d, 0x85
```

#### Continuing

Now do XOR with different pieces of the key.  Here is the current key

```
 84  104   97  116
115   32  109  121
 32   75  117  110
182   90  157  133
```

The first word of output (``w4``) is ``w0 XOR g(w3)``:

```
 84  104   97  116 
182   90  157  133
------------------
226   50  252  241
 e2   32   fc   f1
```

For ``w5`` it's ``w4 XOR w1``

```
226   50  252  241
115   32  109  121
------------------
145   18  145  136
 91   12   91   88
```

For ``w6`` it's ``w5 XOR w2``:

```
145   18  145  136
 32   75  117  110
------------------
177   89  228  230
 b1   59   e4   e6
```

For ``w7`` it's ``w6 XOR w3``:

```
177   89  228  230
103   32   70  117
------------------
214  121  162  147
 d6   79   a2   93
```

At this point, I coded this in Python and then checked the results against the source.

The example came from [here](https://kavaliro.com/wp-content/uploads/2014/03/AES.pdf).  It's great.  There is detailed output for each step.

Here is his printout of the round keys:

```
54 68 61 74 73 20 6D 79 20 4B 75 6E 67 20 46 75
E2 32 FC F1 91 12 91 88 B1 59 E4 E6 D6 79 A2 93
56 08 20 07 C7 1A B1 8F 76 43 55 69 A0 3A F7 FA
D2 60 0D E7 15 7A BC 68 63 39 E9 01 C3 03 1E FB
A1 12 02 C9 B4 68 BE A1 D7 51 57 A0 14 52 49 5B

B1 29 3B 33 05 41 85 92 D2 10 D2 32 C6 42 9B 69
BD 3D C2 B7 B8 7C 47 15 6A 6C 95 27 AC 2E 0E 4E
CC 96 ED 16 74 EA AA 03 1E 86 3F 24 B2 A8 31 6A
8E 51 EF 21 FA BB 45 22 E4 3D 7A 06 56 95 4B 6C
BF E2 BF 90 45 59 FA B2 A1 64 80 B4 F7 F1 CB D8
28 FD DE F8 6D A4 24 4A CC C0 A4 FE 3B 31 6F 26
```

And here is the output of ``round-keys.py``:

```
54 68 61 74 73 20 6d 79 20 4b 75 6e 67 20 46 75
e2 32 fc f1 91 12 91 88 b1 59 e4 e6 d6 79 a2 93
56 08 20 07 c7 1a b1 8f 76 43 55 69 a0 3a f7 fa
d2 60 0d e7 15 7a bc 68 63 39 e9 01 c3 03 1e fb
a1 12 02 c9 b4 68 be a1 d7 51 57 a0 14 52 49 5b
b1 29 3b 33 05 41 85 92 d2 10 d2 32 c6 42 9b 69
bd 3d c2 87 b8 7c 47 15 6a 6c 95 27 ac 2e 0e 4e
cc 96 ed 16 74 ea aa 03 1e 86 3f 24 b2 a8 31 6a
8e 51 ef 21 fa bb 45 22 e4 3d 7a 06 56 95 4b 6c
bf e2 bf 90 45 59 fa b2 a1 64 80 b4 f7 f1 cb d8
28 fd de f8 6d a4 24 4a cc c0 a4 fe 3b 31 6f 26
```

That's a match.